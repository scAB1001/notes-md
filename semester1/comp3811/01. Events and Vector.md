Thursday 09/10/25

---
If resolution is too high to see the pixels:
#### CWK1
- Command line options (see `readme`)
```bash
	--geometry=NxM     (example –geometry=1280x720)
	--fbshift=S        (example –fbshift=1)
```
### Images and Pixels
- Pixel: picture element
- Texel: texture element
- Voxel: volume element
- (Froxel: frustum element(Not as widely accepted.)

Image: grid of pixels
- Raster image
- Vector images a separate topic
- Raster: “a rectangular pattern of parallel [...] lines [...]”
#### Storage
- Array of pixels
- Can use 2D array
- Usually single 1D array (see Exercise 1's surface)
- Same thing: 2D array is stored in linear (=1D) memory
- Doing it "by hand" gives more flexibility
- Nested std::vector<> et al. usually a bad idea...


RGBA/RGBX: 4 bytes
Width = 5 pixels, Height=5 pixels
(Row) stride = 5 * 4 bytes = 20 bytes
First row starts at offset 0, Second row at offset 20
![[row-major-ex.png]]
#### Access
Use the method of access that relates best to how the image is stored.

**Row-major**
```cpp
for( std::size_t xi = xmin; xi < xmax; ++xi )
{
	for( std::size_t yi = ymin; yi < ymax; ++yi )
		Change pixel (xi, yi)
}
```
**Column-major**
```cpp
for( std::size_t yi = ymin; yi < ymax; ++yi )
{
	for( std::size_t xi = xmin; xi < xmax; ++xi )
		Change pixel (xi, yi)
}
```
#### Summary
- Images are stored in memory
- Most common
- Interleaved storage, row major
- RGBx or RGBA
- 8bits / channel = 32 bits in total
### Systems
#### Simplest system
- Video memory is just memory
- Write to video memory
- Screen updated next refresh

“Rich Code for Tiny Computers: A Simple Commodore 64 Game in C++17” Jason Turner, CppCon 2016: https://youtu.be/zBkNBP00wJE

“The world’s worst video card?” Ben Eater, 2019: https://youtu.be/l7rce6IQDWs
#### Modern systems
- More complex
- Screen: shared resource, multiple applications
- Compositor transforms/combines their outputs
- Event handling
- Input devices

##### System Overview
![[sys-overview-os-services.png]]![[sys-overview-opengl-glfw.png]]
### GLFW
- Simple, lightweight library for OpenGL applications
- And Vulkan these days
- Create & manage windows
- Receive events
- Mouse, keyboard
- OS events (window resized, closed, ...)
- Joystick support.
#### Structure
```cpp
- glfwInit()
- glfwCreateWindow()
  ```
- Main Loop (“Hidden” inside `QApplication::exec()`)
	- Pump events
	- Update & Draw
	- Submit for display
-  ```cpp
	- (glfwDestroyWindow())
	- glfwTerminate
	``` 
#### Event Handling
- Qt: Signal + Slot
	- GLFW: Callback functions (or polling)
- GLFW: must pump events
	```cpp
	- glfwWaitEvents() – block until next event
	- glfwPollEvents() – check for events, return immediately
  ```
- Can call multiple times per frame...
#### Callbacks vs. Polling
- Two different ways of doing input.
- Callbacks:
	- System tells us when something happens
	- Suggest using this.
- Polling:
	- We repeatedly ask the system about its state
	- Example: `glfwGetKey()` (need to call that for each key!)
	- Avoid!

**Callbacks**
- GLFW notifies us by calling a function
- Just a normal function
- Address passed to e.g. GLFW so that GLFW knows how to call it

Tangent: Function pointers?
```cpp
using FuncPtr = void (*)(void);
// ...
FuncPtr fptr = &some_void_func();
// ...
fptr();

```
Callback functions
```cpp
struct CallLater
{
	using FuncPtr_ = void (*)(void);
	void set( FuncPtr_ aPtr ) { fptr = aPtr; }
	void call() { fptr(); }
	FuncPtr_ fptr = nullptr;
};
```
Callback functions, II
```cpp
void func()
{
	std::printf( "Hello\n" );
}

int main()
{
	CallLater cl;
	cl.set( &func );
	std::printf( "Test:\n" );
	cl.call();
	cl.call();
	return 0;
}
```
GLFW: Key Input
- `glfwSetKeyCallback()` to register callback function
- `void callback_function( GLFWwindow*, int, int, int, int );`
- Window that received the event
- Key code (identifies which key)
- “Scan code” (also identifies key, but not portable)
- Action (`GLFW_PRESS` or `GLFW_RELEASE; GLFW_REPEAT`)
- Modifiers bitmask (status of shift, alt, ctrl, ...)

### Vector Algebra
Core items
- Points & Vectors
- Coordinate systems
- Different spaces
- Transforms
- Types of transforms
- Sequences of transforms / hierarchical transforms
- Matrices
- Represent transforms
![[vector-camera-image-ex.png]]Markus' take in COMP3811
- Less focus on the how, more on the what/why
- Computer can do computations with numbers
- We need to understand what we need to do
- My opinion:
	- Intuitive understanding of this more important than the details
	- But: should see the details at least once.
- More in-depth
- “Immersive linear algebra” [ILA] Ström, Åström & Akenine-Möller http://immersivemath.com/ila/index.html

Points
- Points: exist without a coordinate system
- If we want to describe them, we use a coordinate system
- Multiple possible coordinate systems
	- In fact, (uncountable) infinitely many
- Different “types” of coordinate systems
	- E.g., cartesian vs. polar coordinates

Coordinate systems
- We will encounter a few different ones
- Will call them “spaces” normally
- E.g., screen space, world space, model space, tangent space, ...
- Comes from “vector space”
- Generalization of coordinate system
- Later: transformations can take us from one space to another

Describing vectors
- Like points, vectors do not require a coordinate system / space
- However, more useful if we put them in one
- Need to do so if we want to represent them in a program
#### Vector spaces
- We define a space with basis vectors 7
- Also called bases
(8,2) = 8 x + 2 y

![[vector-space-ex.png]]
- Bases:
	- x, y and z are common
	- General: ei
- If the bases are orthogonal (=at a right angle) to each other
	- Orthogonal basis
- If the bases are normalised (=length 1)
	- Normal basis
- If both: orthonormal basis
- Do not need to be orthogonal / normal / orthonormal
- Typically prefer **orthonormal** bases
- Makes life a lot easier...

Zero vector (again)
- All vector spaces contain a zero vector
	0 = (0, 0, ...) = origin
- We can interpret this as a point from which we measure out all other points

2D Spaces
- For now focus on 2D spaces
- Two basis vectors
- Later: 3D spaces (with three basis vectors)
- More dimensional spaces exist, all theory works there as well
- Infinite dimensional spaces.
- Not that common in computer graphics, though
- But used (e.g., spherical harmonics)

Recommendation (?)
- Don’t focus too much on the numbers
- Computers do that better
- More important: properties of vectors
- What they represent / mean
- How to manipulate them
- What the operations on them do / mean

Practical notes
In programming:
- Points and vectors not always distinguished
- GLSL: vec2 (ivec2, ...), but no separate point
- vmlib: Vec2f
There are math libraries that use distinct types for the two
- Can be helpful to catch errors --track them mentally?
- Can add two vectors, but can’t add two points
- Different behavior under certain transforms

Summary
- Points & vectors
- Abstract!
- Theory: different
- Practice: often same type
- Basis / base vectors
- Define a vector space
- Gives meaning to a coordinate (u,v) = u x + v y
- Many choices, often want orthonormal!