Thursday 23/10/25

---
#### Triangle
- In 3D: We will define facing based on order of vertices
- CCW is by default front facing, CW is back facing
- Typically cull (=discard) back facing triangles for efficiency
- This is configurable, however
- Can set CW to be front facing, CCW back facing
- Can also choose to cull front facing triangles, none, or both

Half-plane test, you get to choose
- Inside: positive sign
- Outside: negative sign
- Either: all tests have the same sign
##### Generalization
- Approach with half-plane works for any convex shape
- Extends into 3D
- kDOP? (discrete oriented polytope = set of oriented slabs)

Rasterizing triangles
- Can tell if point is in triangle. E.g. half-plane test.
- Last time: â€œpixels = center samplesâ€
- Test each sample position
	- Maybe a bit overkill?
- Can reduce number quite a bit (But still some unnecessary tests.)

Variations of this are common
- Raster stamp on GPUs
- â€œLarrabeeâ€ hierarchical rasterization

Compare: implicit vs explicit
- More like implicit: test points against triangle
- Explicit: enumerate points in triangle?
### Barycentric coordinates
In computer graphics, barycentric coordinates are ==used to represent a point's position within a triangle as a weighted average of its vertices==, allowing for operations like texture mapping and color interpolation. 
- This system is useful for tasks such as rasterization, determining if a point is inside a triangle, and applying lighting or shading across its surface. 
- The coordinates (Î±,Î²,Î³) are defined such that they sum to 1 (Î±+Î²+Î³=1) and are all non-negative (Î±,Î²,Î³â‰¥0)
- Linear interpolation across triangle
- ğ¶ğ‘ƒ = ğ›¼ ğ¶0 + ğ›½ ğ¶1 + ğ›¾ ğ¶2
#### Interpolation
- Arbitrary â€œattributesâ€
- Easy to show with colors
- Depth (for depth buffering / hidden surface removal)
- Texture coordinates (for texture mapping)
- Surface normals (for lighting)
- Tangent space bases (for normal mapping)
- Note: 3D: need to correct for perspective. (extra interpolation)
##### Equation: ğ¶ğ’™ = ğ›¼ ğ¶ğ‘œ + ğ›½ ğ¶1 + ğ›¾ ğ¶2
Properties:
- Each of ğ›¼, ğ›½ and ğ›¾ should be in the range [0 â€¦ 1]
	- ğ›¼ + ğ›½ + ğ›¾ = 1, ğ›¼ < 1, ğ›½ < 1, ğ›¾ < 1
- First property: inside of space spanned by ğ¶ğ‘œ, ğ¶1 and ğ¶2
- Second property: conserve â€œenergyâ€
#### Sketch
- Line: 1 âˆ’ ğ‘¡ ğ‘ƒ + ğ‘¡ ğ‘„, ğ‘¡ âˆˆ [0 â€¦ 1]
- Works for any point V in triangle
![[drawing-triangles-ex.png]]
ğ‘‰ = (1 âˆ’ ğ‘ ) ğ¶ + ğ‘  ğ‘ˆ
ğ‘‰ = (1 âˆ’ ğ‘ ) ğ¶ + ğ‘  ((1 âˆ’ ğ‘¡) ğ´ + ğ‘¡ ğµ)
ğ‘‰ = (1 âˆ’ ğ‘ ) ğ¶ + (1 âˆ’ ğ‘¡) ğ‘  ğ´ + ğ‘  ğ‘¡ ğµ
ğ‘‰ = ğ›¾ ğ¶ + ğ›¼ ğ´ + ğ›½ ğµ, with ğ›¼ = (1 âˆ’ t) s, ğ›½ = ğ‘  ğ‘¡ and ğ›¾ = (1 âˆ’ s)
#### Barycentric coordinates
- Properties: ğ›¼, ğ›½, ğ›¾ âˆˆ 0 â€¦ 1 and ğ›¼ + ğ›½ + ğ›¾ = 1 with ğ›¼ = 1 âˆ’ t s, ğ›½ = ğ‘  ğ‘¡ and ğ›¾ = (1 âˆ’ s)

The barycentric coordinates of a point are ğ›¼, ğ›½, ğ›¾
- Relative to a specific triangle ABC
- ğ›¼, ğ›½, ğ›¾ âˆˆ [0 â€¦ 1]
- ğ›¼ + ğ›½ + ğ›¾ = 1
- The properties also imply ğ›¾ = 1 âˆ’ ğ›¼ âˆ’ ğ›½

Given a point X: can we compute its barycentric coordinate?
Different geometric interpretation
- Weâ€™ve already seen one
- Original triangle: ABC
- Subtriangles ABU, BCU, AUC

This gives us one way to compute barycentric coodinates
- Given point U, compute the four areas and perform the divisions
(Sanity check: no divisions by zero unless the original triangle is
degenerate)
- Triangle area with sine rule
ğ´ğ‘Ÿğ‘’ğ‘_ğ´ğµğ¶ = $\frac {\lVert u \rVert \cdot \lVert v \rVert \cdot sin ğœƒ}{2}$

Sine is expensive to evaluate, so donâ€™t like that.
- Trick: Cross product
$u \cdot p = \lVert u \rVert \cdot \lVert v \rVert \cdot sin ğœƒ \cdot n$
- Cross product is a vector (hence the multiplication by n, n unit length)
- But:
$\lVert u \cdot p \rVert = \lVert u \rVert \cdot \lVert v \rVert \cdot \lvert sin ğœƒ \rvert$
which is pretty much what weâ€™re looking for.
#### How they are used in graphics?
- **Interpolation:**    
For any point P inside a triangle defined by vertices A, B, and C, its position can be expressed as
ğ‘ƒ=ğ›¼ğ´+ğ›½ğµ+ğ›¾ğ¶
This equation allows for smooth interpolation of other values, such as color or texture coordinates, across the triangle's surface by interpolating the vertex values using the same barycentric weights.Â 

- **Point-in-triangle tests:-**
A point is inside or on the boundary of a triangle if and only if its barycentric coordinates are all non-negative and sum to 1. This is a fundamental check used in rasterization to determine which pixels to draw.Â 

- **[Ray-triangle intersection](https://www.google.com/search?client=firefox-b-lm&channel=entpr&cs=1&sca_esv=bf302389b4c6e1ea&sxsrf=AE3TifMr4pYdnAGFxxTztBIKTgAo6UX29Q%3A1761209066736&q=Ray-triangle+intersection&sa=X&ved=2ahUKEwjG6fGF97mQAxVnUEEAHTZ6Pa4QxccNegQIExAB&mstk=AUtExfAbrTdn-LDU7QimOHgp-wQtdFVfa2eTWNpOdrvIcxPHSz9Y1zkrOuvZsLS7DBKxrjb2RvMi6dC7RMQAuqbJRS2LQi5kMPUjH0xi2lMlaf_j6aW9EvdwH29tIP0TskOFk0laZywcc40DexzOiVJKjcSsf0cICBq_t0Z7JskMDN3HPBw&csui=3):**
Barycentric coordinates are a key component of efficient ray-triangle intersection algorithms, such as the MÃ¶ller-Trumbore algorithm.Â 

- **Shading:**
They are used to apply lighting and shading effects. For example, the normal vector or other material properties can be interpolated across the surface to create realistic shading.Â 

- **Texture mapping:**
Barycentric coordinates are essential for mapping textures onto triangles, as they provide a way to find the correct texture coordinate for any point within the triangle.Â 

- **Surface modeling:**
They are used in computer-aided design for defining and manipulating surfaces, such as [BÃ©zier surfaces](https://www.google.com/search?client=firefox-b-lm&channel=entpr&cs=1&sca_esv=bf302389b4c6e1ea&sxsrf=AE3TifMr4pYdnAGFxxTztBIKTgAo6UX29Q%3A1761209066736&q=B%C3%A9zier+surfaces&sa=X&ved=2ahUKEwjG6fGF97mQAxVnUEEAHTZ6Pa4QxccNegQIJRAB&mstk=AUtExfAbrTdn-LDU7QimOHgp-wQtdFVfa2eTWNpOdrvIcxPHSz9Y1zkrOuvZsLS7DBKxrjb2RvMi6dC7RMQAuqbJRS2LQi5kMPUjH0xi2lMlaf_j6aW9EvdwH29tIP0TskOFk0laZywcc40DexzOiVJKjcSsf0cICBq_t0Z7JskMDN3HPBw&csui=3).Â 
Barycentric coordinate system - Wikipedia
Barycentric coordinates are particularly useful in triangle geometry for studying properties that do not depend on the angles of the triangle
* We call p the Phong exponent p is also referred to as the shininess value and is treated as a propety of the surface material.
#### Mathematical representation
- **Vertices:** Let the vertices of a triangle be A, B, and C.
- **Point:** Let P be a point within or on the triangle.
- **Coordinates:** P can be expressed as a weighted average of the vertices: ğ‘ƒ=ğ›¼ğ´+ğ›½ğµ+ğ›¾ğ¶.Â 
- **Constraint:** The weights must satisfy the conditions: ğ›¼+ğ›½+ğ›¾=1 and ğ›¼,ğ›½,ğ›¾â‰¥0.Â 
- **Alternative view:** The coordinates can also be thought of as the ratio of the areas of the sub-triangles formed by the point P and the triangle's edges. 
- For a point P inside triangle ABC, the barycentric coordinates are (ğ›¼,ğ›½,ğ›¾) = 
	(ğ´ğ‘Ÿğ‘’ğ‘(ğ‘ƒğµğ¶)/ğ´ğ‘Ÿğ‘’ğ‘(ğ´ğµğ¶), ğ´ğ‘Ÿğ‘’ğ‘(ğ‘ƒğ´ğ¶)/ğ´ğ‘Ÿğ‘’ğ‘(ğ´ğµğ¶), ğ´ğ‘Ÿğ‘’ğ‘(ğ‘ƒğ´ğµ)/ğ´ğ‘Ÿğ‘’ğ‘(ğ´ğµğ¶)), which is why they are also called [areal coordinates](https://www.google.com/search?client=firefox-b-lm&channel=entpr&cs=1&sca_esv=bf302389b4c6e1ea&sxsrf=AE3TifMr4pYdnAGFxxTztBIKTgAo6UX29Q%3A1761209066736&q=areal+coordinates&sa=X&ved=2ahUKEwjG6fGF97mQAxVnUEEAHTZ6Pa4QxccNegQIRBAC&mstk=AUtExfAbrTdn-LDU7QimOHgp-wQtdFVfa2eTWNpOdrvIcxPHSz9Y1zkrOuvZsLS7DBKxrjb2RvMi6dC7RMQAuqbJRS2LQi5kMPUjH0xi2lMlaf_j6aW9EvdwH29tIP0TskOFk0laZywcc40DexzOiVJKjcSsf0cICBq_t0Z7JskMDN3HPBw&csui=3).

### P2 of lecture (page 55+)
Alternative rasterization
- So far: â€œimplicitâ€
- Test candidate points against triangle
- Draw those that pass test
- (This is less bad than for lines)
- Would (maybe) like to have method that allows us to find points that
correspond to pixels
We know how to follow a line
- General idea
- Follow edge (=line segment)
- For each step in y: fill in the row
Advantage: filling in rows is efficient in row-major images
- Column-major: instead operate on columns.
Problemâ€: other edges and different types of triangles

Trick
- We can reduce triangles to two cases
- â€œFlat topâ€ and â€œflat bottomâ€
- Apply previous idea to those
- Original triangle:
- Split in two
![[flat-top-bottom-triangles.png]] 

GPUs
- Rasterization hardware
- Typically deals with multiple samples in parallel
- â€œRaster stampâ€
- Something like a 2x2 or 4x4 (or 4x8) quad
- Different for different HW
- Advantage: parallel execution, derivatives
- Disadvantage: wasted computations
![[gpu-triangle-rasterization.png]]
Additional problem:
- Need to make sure that adjacent triangles
do not overlap (i.e., pixels along edges
should only be drawn once).
- Tie-breaker rulesâ€¦
![[gpu-overlapping-triangle-issue.png]]
Small triangles are typically more costly because of this
- Also: Fullscreen
- Traditionally: quad = two triangles
- Now: Single triangle (clipped)
#### Clipping and culling
- Same problems as with lines
- Mustnâ€™t draw outside of the framebuffer
Implicit methods:
- Easy: donâ€™t consider points from outside of the framebuffer.
- Explicit methods: :(

Not only need to do that
- But then need to triangulate the result again
- Otherwise: generally same idea as with lines:
- Edges are lines. Clip against axes.

Middle ground suggestion (from Tricks):
- Focus on flat top and flat bottom triangles
- Clip edge against view port, skipping parts that are outside
- When drawing each scan line, clip its start and end (simple)
- Important: just donâ€™t test each sample/pixel individually!

#### Blit
- Variations: blit, bit blit, blt, â€¦
- â€œBit block transferâ€
- Essentially: copy block of pixels to another block
- Block: rectangular region
- Optional extra operations
- Masking, blending
- Transformations (scaling, rotation?)
- Color format conversions

One of the early HW accelerated operations
- At least on consumer hardware
- E.g., Amiga
- Still shows up in modern APIs
- OpenGL: `glBlitFramebuffer()`, `glCopyTexSubImage2D()`
- Vulkan: `vkCmdBlitImage()`
- â€œLimitedâ€ to format conversions and scaling
##### Essentials
- Simple CPU implementation: copy data line by line
- Row-by-row for row major
- Column-by-column for column major
- Double `for` loop
Can do some minor optimizations
- E.g., avoid multiplications in loop, increment by pixel offset and stride
- GCC/MSVC werenâ€™t able to do that in a quick test (but moving away from copying single bytes probably has a bigger impact)

Blit â€“ Clipping
- Clip against destination image
- Adjust rectangle to be copied
![[blit-clipping-ex.png]]
Personal opinion:
- I would consider it to be unnecessary to clip against the source image
- It seems like a programming error in most cases
- But: many APIs will handle that case anyway

Blit â€“ Masking
- Example from before
- Uses a mask to determine what pixels to copy
- Mask: essentially a boolean value
![[background-masked-for-blit.png]]![[blit-to-be-masked.png]]
Typically stored in Alpha-channel
- 0â€¦255 in 8-bit
- 0â€¦1.0 in float
- Used for alpha blending; alpha = 0 has a similar effect as masking
- Sometimes stored as a separate image
- Some formats have 1-bit alpha support
- BC1 compressed format
##### How to
- Read mask value (or whole source pixel if in alpha channel)
- Check if mask is below some threshold
- If below threshold: skip this pixel
- If above threshold: copy pixel as normally
Threshold:
- Standard alpha: use â‰¤ 0 as alpha = zero means fully transparent
- Using e.g. â‰¤ 128 or â‰¤ 0.5 can result in slightly nicer borders
	- Depends on input data. Somewhat tweakable.
#### Blit â€“ Blending
- Most commonly: alpha blending
- Alpha specifies opacity/transparency
- 0.0 = fully transparent
- 1.0 = fully opaque (255 in 8bit)
- In between: blend of foreground and background
![[blit-blending-ex.png]]
Normally:
- Background: previous contents of image = â€œdestinationâ€
- Foreground: image weâ€™re blitting = â€œsourceâ€
- Alpha blending: linear mix / interpolation between the two
	ğ‘“ğ‘–ğ‘›ğ‘ğ‘™ğ¶ğ‘œğ‘™ğ‘œğ‘Ÿ = ğ›¼ â‹… ğ‘ ğ‘œğ‘¢ğ‘Ÿğ‘ğ‘’ğ¶ğ‘œğ‘™ğ‘œğ‘Ÿ + (1 âˆ’ ğ›¼) â‹… ğ‘‘ğ‘’ğ‘ ğ‘¡ğ‘–ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›ğ¶ğ‘œğ‘™ğ‘œğ‘Ÿ
	(Important: source and destination colors in linear RGB!)