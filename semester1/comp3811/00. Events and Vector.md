Thursday 09/10/25

---
If resolution is too high to see the pixels:
#### CWK1
- Command line options (see `readme`)
```bash
	--geometry=NxM     (example –geometry=1280x720)
	--fbshift=S        (example –fbshift=1)
```
### Images and Pixels
- Pixel: picture element
- Texel: texture element
- Voxel: volume element
- (Froxel: frustum element(Not as widely accepted.)

Image: grid of pixels
- Raster image
- Vector images a separate topic
- Raster: “a rectangular pattern of parallel [...] lines [...]”
#### Storage
- Array of pixels
- Can use 2D array
- Usually single 1D array (see Exercise 1's surface)
- Same thing: 2D array is stored in linear (=1D) memory
- Doing it "by hand" gives more flexibility
- Nested std::vector<> et al. usually a bad idea...


RGBA/RGBX: 4 bytes
Width = 5 pixels, Height=5 pixels
(Row) stride = 5 * 4 bytes = 20 bytes
First row starts at offset 0, Second row at offset 20
![[row-major-ex.png]]
#### Access
Use the method of access that relates best to how the image is stored.

**Row-major**
```cpp
for( std::size_t xi = xmin; xi < xmax; ++xi )
{
	for( std::size_t yi = ymin; yi < ymax; ++yi )
		Change pixel (xi, yi)
}
```
**Column-major**
```cpp
for( std::size_t yi = ymin; yi < ymax; ++yi )
{
	for( std::size_t xi = xmin; xi < xmax; ++xi )
		Change pixel (xi, yi)
}
```
#### Summary
- Images are stored in memory
- Most common
- Interleaved storage, row major
- RGBx or RGBA
- 8bits / channel = 32 bits in total
### Systems
#### Simplest system
- Video memory is just memory
- Write to video memory
- Screen updated next refresh

“Rich Code for Tiny Computers: A Simple Commodore 64 Game in C++17” Jason Turner, CppCon 2016: https://youtu.be/zBkNBP00wJE

“The world’s worst video card?” Ben Eater, 2019: https://youtu.be/l7rce6IQDWs
#### Modern systems
- More complex
- Screen: shared resource, multiple applications
- Compositor transforms/combines their outputs
- Event handling
- Input devices

##### System Overview
![[sys-overview-os-services.png]]![[sys-overview-opengl-glfw.png]]
### GLFW
- Simple, lightweight library for OpenGL applications
- And Vulkan these days
- Create & manage windows
- Receive events
- Mouse, keyboard
- OS events (window resized, closed, ...)
- Joystick support.
#### Structure
```cpp
- glfwInit()
- glfwCreateWindow()
  ```
- Main Loop (“Hidden” inside `QApplication::exec()`)
	- Pump events
	- Update & Draw
	- Submit for display
-  ```cpp
	- (glfwDestroyWindow())
	- glfwTerminate
	``` 
#### Event Handling
- Qt: Signal + Slot
	- GLFW: Callback functions (or polling)
- GLFW: must pump events
	```cpp
	- glfwWaitEvents() – block until next event
	- glfwPollEvents() – check for events, return immediately
  ```
- Can call multiple times per frame...

Callbacks vs. Polling
- Two different ways of doing input.
- Callbacks:
	- System tells us when something happens
	- Suggest using this.
- Polling:
	- We repeatedly ask the system about its state
	- Example: `glfwGetKey()` (need to call that for each key!)
	- Avoid!