Thursday 09/10/2025

---
#### Module Objectives
- Understand the different ways on how to view the organisation of a distributed system.
- Organisation of the distributed systems is mostly about the software components that constitute the system
- The software architectures tell us how the various software components are to be organized
- Goal: separate applications from underlying platforms by providing the middleware layer
- The instantiation of a software architecture (placement of software components on real machines) is referred to as a system architecture.
#### Architectural Style 
Is formulated in terms of:
- (replaceable) components with well-defined interfaces
- the way that components are connected to each other
- the data exchanged between components
- how these components and connectors are jointly configured into a system.
![[machine-interfaces.png]]
Component A has B’s interface.  Component B has C’s. C has E’s. D has B’s.
##### Architectural Styles for Distributed Systems
1. Layered architectures
2. Object-based architectures
3. Resource-centred architectures
4. Event-based architectures - Publish-subscribe
Note: in (2) and (3), each entity encapsulates a service, object or microservice. More in lecture on Service oriented Architectures.
#### Layered Architectures
The basic idea for the layered style is simple: components are organized in a layered fashion where a component at layer Lj can make a downcall to a component at a lower-level layer Li (with i < j) and generally expects a response. Only in exceptional cases will an upcall be made to a higher-level component.
![[layered-architectures.png]](a) Pure layered organisation
(b) Mixed layered organisation
(c) Layered organisation with upcalls
##### Layered communication protocol
A well-known and ubiquitously applied layered architecture is that of so-called communication-protocol stacks.
- In these stacks, each layer implements one or several communication services allowing data to be sent from a destination to one or several targets. 
- To this end, each layer offers an interface specifying the functions that can be called. 
- In principle, the interface should completely hide the actual implementation of a service. 

Another important concept in the case of communication is that of a (communication) protocol, which describes the rules that parties will follow in order to exchange information. 
![[layered-communication-protocol-ex.png]]
_A layered communication protocol stack, showing the difference between a service, its interface, and the protocol it deploys._

It is important to understand the difference between a service offered by a layer, the interface by which that service is made available, and the protocol that a layer implements to establish communication.
###### Example: TCP
To make this distinction clear, consider a reliable, connection-oriented service, which is provided by many communication systems. 

In this case, a communicating party first needs to set up a connection to another party before the two can send and receive messages. 
- Being reliable means that strong guarantees will be given that sent messages will indeed be delivered to the other side, even when there is a high risk that messages may be lost (as, for example, may be the case when using a wireless medium). 
- In addition, such services generally also ensure that messages are delivered in the same order as that they were sent. 

This kind of service is realized in the Internet by the **Transmission Control Protocol (TCP).** 
- The protocol specifies which messages are to be exchanged for setting up or tearing down a connection, what needs to be done to preserve the ordering of transferred data, and what both parties need to do to detect and correct data that was lost during transmission. 
- The service is made available in the form of a relatively simple programming interface, containing calls to set up a connection, send and receive messages, and to tear down the connection again. In fact, there are different interfaces available, often dependent on operating system or programming language used. 
- Likewise, there are many different implementations of the protocol and its interfaces
##### Application Layering: the PAD Model
Many client-server applications are constructed logically from three different layers of software
1. **Presentation layer**: application-interface
	 Contains everything required to interface with user of the system

1. **Application layer**: processing
	A processing layer, containing core functionality of the system

1. **Data layer**: data
	Responsible for persistent storage of the data on which application layer operates 
	Can map these layers onto a physical client-server architecture in various ways

![[pad-search-engine-ex.png]]*The general organisation of an Internet search engine into three different layers*

**A Search on Google Cloud: How it is Handled**
- load balancer: application-layer routing
![[cloud-search-ex.png]]
Search for: “Jay Kelly”
- receives external client requests
- directs workload within data centre
- returns results to external client (hiding data centre internals from client)
#### Object-based and service-oriented architectures 
In essence, each object corresponds to what we have defined as a **component**, and these components are connected through a **procedure call mechanism**. 
In the case of distributed systems, a procedure call can also take place over a network, that is, the calling object need not be executed on the same machine as the called object. E.g. RMI.

Object-based architectures are attractive because they provide a natural way of **encapsulating** data (called an _object’s state_) and the operations that can be performed on that data (which are referred to as an _object’s methods_) into a single entity. 

The **interface** offered by an object conceals implementation details, essentially meaning that we, in principle, can consider an object completely independent of its environment. 

As with components, this also means that if the interface is clearly defined and left otherwise untouched, an object should be replaceable with one having exactly the same interface. 
- This separation between interfaces and the objects implementing these interfaces allows us to place an interface at one machine, while the object itself resides on another machine. 
- This organization is commonly referred to as a **distributed object**. 

When a client **binds** to a distributed object, an implementation of the object’s interface, called a **proxy**, is then loaded into the client’s address space. 
- A proxy is analogous to a client stub in RPC systems. 
- The only thing it does is marshal method invocations into messages and unmarshal reply messages to return the result of the method invocation to the client. 
- The actual object resides at a server machine, where it offers the same interface as it does on the client machine. 
- Incoming invocation requests are first passed to a server stub, which unmarshals them to make method invocations at the object’s interface at the server. 
- The server stub is also responsible for marshaling replies and forwarding reply messages to the client-side proxy.
![[object-based-arch-remote-obj-client-side-proxy.png]]
The server-side stub is often referred to as a skeleton as it provides the bare means for letting the server middleware access the user-defined objects. 

In practice, it often contains incomplete code in the form of a language-specific class that needs to be further specialized by the developer. 

A characteristic, but somewhat counterintuitive feature of most distributed objects is that their state is not distributed: 
- it resides at a single machine.
- Only the interfaces implemented by the object are made available on other machines.  
- Such objects are also referred to as remote objects. 

In a general distributed object, the state itself may be physically distributed across multiple machines, but this distribution is also hidden from clients behind the object’s interfaces. 

One could argue that object-based architectures form the foundation of encapsulating services into independent units. 
Encapsulation is the keyword here: 
- the service as a whole is realized as a self-contained entity, although it can possibly make use of other services. 
- By clearly separating various services such that they can operate independently, we are paving the road toward service-oriented architectures, generally abbreviated as SOAs. 

In a service-oriented architecture, a distributed application or system is essentially constructed as a composition of many different services. 
- Not all of these services may belong to the same administrative organization. 
- It may very well be that an organization running its business application makes use of storage services offered by a cloud provider. 
- These storage services are logically completely encapsulated into a single unit, of which an interface is made available to customers. 
- Of course, storage is a rather basic service, but more sophisticated situa- tions easily come to mind. Consider, for example, a Web shop selling goods such as e-books. 
###### Example
A simple implementation following the application layering we discussed previously, may consist of an application for processing orders, which, in turn, operates on a local database containing the e-books.

Order processing typically involves selecting items, registering and checking the delivery channel (perhaps by making use of e-mail), but also making sure that a payment takes place. 

The latter can be handled by a separate service, run by a different organization, to which a purchasing customer is redirected for the payment, after which the e-book organization is notified so that it can complete the transaction. 

In this way, we see that the problem of developing a distributed system is partly one of service composition, and making sure that those services operate in harmony. 

Indeed, this problem is completely analogous to enterprise application integration issues. Crucial is, and remains, that each service offers a well-defined (programming) interface. 

In practice, this also means that each service offers its own interface, in turn, possibly making the composition of services far from trivial.
#### Resource-based architectures
As an increasing number of services became available over the Web and the development of distributed systems through service composition became more important, researchers started to rethink the architecture of mostly Web-based distributed systems. 

One of the problems with service composition is that connecting various components can easily turn into an integration nightmare. 
 - As an alternative, one can also view a distributed system as a huge collection of resources that are individually managed by components. 
 - Resources may be added or removed by (remote) applications, and likewise can be retrieved or modified. 
 - All services offer the same interface
- Messages sent to or from a service are fully self-described
- After executing an operation at a service, that component forgets everything about the caller

This approach has now been widely adopted for the Web and is known as **Representational State Transfer (REST)** [Fielding, 2000]. 

There are four key characteristics of what are known as RESTful architectures:
1. Resources are identified through a single naming scheme
2. All services offer the same interface, consisting of at most four operations
3. Messages sent to or from a service are fully self-described
4. After executing an operation at a service, that component forgets everything about the caller (**stateless execution**)
##### CRUD operations used in RESTful architectures

| Operation | Description                                                 |
| --------- | ----------------------------------------------------------- |
| `POST`    | **C**reate a new resource                                   |
| `GET`     | **R**etrieve the state of a resource in some representation |
| `PUT`     | **U**pdate (modify) a resource by transferring a new state  |
| `DELETE`  | **D**elete a resource                                       |
##### Example: Amazon’s Simple Storage Service (Amazon S3)
To illustrate how RESTful can work in practice, consider a cloud storage service.
Amazon S3, described in [Murty, 2008] supports only two resources: 
1. objects, which are essentially the equivalent of files, and 
2. buckets, the equivalent of directories. 

There is no concept of placing buckets into buckets. 
An object named `ObjectName` contained in bucket `BucketName` is referred to by the following **Uniform Resource Identifier (URI)**: http://BucketName.s3.amazonaws.com/ObjectName 

To create a bucket, or an object for that matter, an application would essentially 
- send a PUT request with the URI of the bucket/object. 
	- In principle, the protocol that is used with the service is HTTP. 
	- This is just another HTTP request to be interpreted by S3. 
- If the bucket or object already exists, an HTTP error message is returned. 

In a similar fashion, to know which objects are contained in a bucket, an application would 
- send a GET request with the URI of that bucket. 
- S3 will return a list of object names, again as an ordinary HTTP response. 
###### Advantages and Disadvantages
In particular, the simplicity of RESTful architectures can easily prohibit easy solutions to intricate communication schemes. 
- One example is where distributed transactions are needed, which generally requires that services keep track of the state of execution. 
- On the other hand, there are many examples in which RESTful architectures perfectly match a simple integration scheme of services, yet where the myriad of service interfaces will complicate matters
#### Publish-subscribe (event-based) architectures
As systems continue to grow and processes can more easily join or leave, it becomes important to have an architecture in which dependencies between processes become as loose as possible. 
##### General
A large class of distributed systems have adopted an architecture in which there is a strong separation between _processing_ and _coordination_. 
- The idea is to view a system as a collection of _autonomously operating processes_. 
- In this model, **coordination** encompasses the communication and cooperation between processes. 
- It forms the glue that binds the activities performed by processes into a whole [Gelernter and Carriero, 1992]. 

Slightly adapting the terminology from Cabri et al. [2000], we make a distinction between models along two different dimensions, temporal and referential.

|                             | **Temporally coupled** | **Temporally decoupled** |
| --------------------------- | ---------------------- | ------------------------ |
| **Referentially coupled**   | Direct                 | Mailbox                  |
| **Referentially decoupled** | Event-based            | Shared data space        |
##### Types of coordination
**Temporally and referentially coupled processes**
Coordination takes place in a direct way, referred to as **direct coordination**. 
###### Referential coupling
Appears in the form of explicit referencing in communication. 
- For example, a process can communicate only if it knows the name or identifier of the other processes it wants to exchange information with. 
###### Temporal coupling 
Processes that are communicating will both have to be up and running. 
- In real life, talking over cell phones (and assuming that a cell phone has only one owner), is an example of direct communication.
###### Temporally decoupled, but referentially coupled processes
Referred to as **mailbox coordination**. 
- In this case, there is no need for two communicating processes to be executing at the same time in order to let communication take place. 
- Instead, communication takes place by putting messages in a (possibly shared) mail-box. Because it is necessary to explicitly address the mailbox that will hold the messages that are to be exchanged, there is a referential coupling. 
###### Referentially decoupled and temporally coupled processes (systems) 
Form the group of models for **event-based coordination**. 
- In referentially decoupled systems, processes do not know each other explicitly. 
- The only thing a process can do is **publish** a **notification** describing the occurrence of an event (e.g., that it wants to coordinate activities, or that it just produced some interesting results). 
- Assuming that notifications come in all sorts and kinds, processes may **subscribe** to a specific kind of notification (see also [Mühl et al., 2006]). 
	- In an ideal event-based coordination model, a published notification will be delivered _exactly_ to those processes that have subscribed to it. 
	- However, it is generally required that the subscriber is _up-and-running_ at the time the notification was published. 
###### Referentially and temporally decoupled processes
Known as a **shared data space**. 
- The key idea is that processes communicate entirely through **tuples**, which are structured data records consisting of a number of fields, very similar to a row in a database table. 
- Processes can put any type of tuple into the shared data space. 
- In order to retrieve a tuple, a process provides a **search pattern** that is matched against the tuples with any matches being returned.

Shared data spaces are thus seen to implement an associative search mechanism for tuples.
- When a process wants to extract a tuple from the data space, it specifies (some of) the values of the fields it is interested in. 
	- Any tuple that matches that specification is then removed from the data space and passed to the process 
- Shared data spaces are often combined with event-based coordination: 
	- a process subscribes to certain tuples by providing a search pattern; when a process inserts a tuple into the data space, matching subscribers are notified. 
	- In both cases, we are dealing with a **publish-subscribe** architecture, and indeed, the key characteristic feature is that processes have no explicit reference to each other. 
- We have also shown an abstraction of the mechanism by which publishers and subscribers are matched, known as an **event bus**.

![[event-based-vs-shared-data-space-arch-ex.png]]
_The difference between a pure event-based architectural style, and that of a shared data space. _
