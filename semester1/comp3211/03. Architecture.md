Thursday 09/10/2025

---
#### Module Objectives
- Understand the different ways on how to view the organisation of a distributed system.
- Organisation of the distributed systems is mostly about the software components that constitute the system
- The software architectures tell us how the various software components are to be organized
- Goal: separate applications from underlying platforms by providing the middleware layer
- The instantiation of a software architecture (placement of software components on real machines) is referred to as a system architecture.
#### Architectural Style 
Is formulated in terms of:
- (replaceable) components with well-defined interfaces
- the way that components are connected to each other
- the data exchanged between components
- how these components and connectors are jointly configured into a system.
![[machine-interfaces.png]]
Component A has B’s interface.  Component B has C’s. C has E’s. D has B’s.
### Architectural Styles for Distributed Systems
1. Layered architectures
2. Object-based architectures
3. Resource-centred architectures
4. Event-based architectures - Publish-subscribe
Note: in (2) and (3), each entity encapsulates a service, object or microservice. More in lecture on Service oriented Architectures.
#### Layered Architectures
The basic idea for the layered style is simple: components are organized in a layered fashion where a component at layer Lj can make a downcall to a component at a lower-level layer Li (with i < j) and generally expects a response. Only in exceptional cases will an upcall be made to a higher-level component.
![[layered-architectures.png]](a) Pure layered organisation
(b) Mixed layered organisation
(c) Layered organisation with upcalls
##### Layered communication protocol
A well-known and ubiquitously applied layered architecture is that of so-called communication-protocol stacks.
- In these stacks, each layer implements one or several communication services allowing data to be sent from a destination to one or several targets. 
- To this end, each layer offers an interface specifying the functions that can be called. 
- In principle, the interface should completely hide the actual implementation of a service. 

Another important concept in the case of communication is that of a (communication) protocol, which describes the rules that parties will follow in order to exchange information. 
![[layered-communication-protocol-ex.png]]
_A layered communication protocol stack, showing the difference between a service, its interface, and the protocol it deploys._

It is important to understand the difference between a service offered by a layer, the interface by which that service is made available, and the protocol that a layer implements to establish communication.
###### Example: TCP
To make this distinction clear, consider a reliable, connection-oriented service, which is provided by many communication systems. 

In this case, a communicating party first needs to set up a connection to another party before the two can send and receive messages. 
- Being reliable means that strong guarantees will be given that sent messages will indeed be delivered to the other side, even when there is a high risk that messages may be lost (as, for example, may be the case when using a wireless medium). 
- In addition, such services generally also ensure that messages are delivered in the same order as that they were sent. 

This kind of service is realized in the Internet by the **Transmission Control Protocol (TCP).** 
- The protocol specifies which messages are to be exchanged for setting up or tearing down a connection, what needs to be done to preserve the ordering of transferred data, and what both parties need to do to detect and correct data that was lost during transmission. 
- The service is made available in the form of a relatively simple programming interface, containing calls to set up a connection, send and receive messages, and to tear down the connection again. In fact, there are different interfaces available, often dependent on operating system or programming language used. 
- Likewise, there are many different implementations of the protocol and its interfaces
##### Application Layering: the PAD Model
Many client-server applications are constructed logically from three different layers of software
1. **Presentation layer**: application-interface
	 Contains everything required to interface with user of the system

1. **Application layer**: processing
	A processing layer, containing core functionality of the system

1. **Data layer**: data
	Responsible for persistent storage of the data on which application layer operates 
	Can map these layers onto a physical client-server architecture in various ways

![[pad-search-engine-ex.png]]*The general organisation of an Internet search engine into three different layers*

**A Search on Google Cloud: How it is Handled**
- load balancer: application-layer routing
![[cloud-search-ex.png]]
Search for: “Jay Kelly”
- receives external client requests
- directs workload within data centre
- returns results to external client (hiding data centre internals from client)
#### Object-based and service-oriented architectures 
In essence, each object corresponds to what we have defined as a **component**, and these components are connected through a **procedure call mechanism**. 
In the case of distributed systems, a procedure call can also take place over a network, that is, the calling object need not be executed on the same machine as the called object. E.g. RMI.

Object-based architectures are attractive because they provide a natural way of **encapsulating** data (called an _object’s state_) and the operations that can be performed on that data (which are referred to as an _object’s methods_) into a single entity. 

The **interface** offered by an object conceals implementation details, essentially meaning that we, in principle, can consider an object completely independent of its environment. 

As with components, this also means that if the interface is clearly defined and left otherwise untouched, an object should be replaceable with one having exactly the same interface. 
- This separation between interfaces and the objects implementing these interfaces allows us to place an interface at one machine, while the object itself resides on another machine. 
- This organization is commonly referred to as a **distributed object**. 

When a client **binds** to a distributed object, an implementation of the object’s interface, called a **proxy**, is then loaded into the client’s address space. 
- A proxy is analogous to a client stub in RPC systems. 
- The only thing it does is marshal method invocations into messages and unmarshal reply messages to return the result of the method invocation to the client. 
- The actual object resides at a server machine, where it offers the same interface as it does on the client machine. 
- Incoming invocation requests are first passed to a server stub, which unmarshals them to make method invocations at the object’s interface at the server. 
- The server stub is also responsible for marshaling replies and forwarding reply messages to the client-side proxy.
![[object-based-arch-remote-obj-client-side-proxy.png]]
The server-side stub is often referred to as a skeleton as it provides the bare means for letting the server middleware access the user-defined objects. 

In practice, it often contains incomplete code in the form of a language-specific class that needs to be further specialized by the developer. 

A characteristic, but somewhat counterintuitive feature of most distributed objects is that their state is not distributed: 
it resides at a single machine. 
Only the interfaces implemented by the object are made available on other machines. 
Such objects are also referred to as remote objects. 

In a general distributed object, the state itself may be physically distributed across multiple machines, but this distribution is also hidden from clients behind the object’s interfaces. 

One could argue that object-based architectures form the foundation of encapsulating services into independent units. 
Encapsulation is the keyword here: 
- the service as a whole is realized as a self-contained entity, although it can possibly make use of other services. 
- By clearly separating various services such that they can operate independently, we are paving the road toward service-oriented architectures, generally abbreviated as SOAs. 

In a service-oriented architecture, a distributed application or system is essentially constructed as a composition of many different services. 
- Not all of these services may belong to the same administrative organization. 
- It may very well be that an organization running its business application makes use of storage services offered by a cloud provider. These storage services are logically completely encapsulated into a single unit, of which an interface is made available to customers. Of course, storage is a rather basic service, but more sophisticated situa- tions easily come to mind. Consider, for example, a Web shop selling goods such as e-books. A simple implementation following the application layering we discussed previously, may consist of an application for processing orders, which, in turn, operates on a local database containing the e-books. Order processing typically involves selecting items, registering and checking the delivery channel (perhaps by making use of e-mail), but also making sure that a payment takes place. The latter can be handled by a separate service, run by a different organization, to which a purchasing customer is redirected for the payment, after which the e-book organization is notified so that it can complete the transaction. In this way, we see that the problem of developing a distributed system is partly one of service composition, and making sure that those services operate in harmony. Indeed, this problem is completely analogous to the enterprise application integration issues discussed in Section 1.3. Crucial is, and remains, that each service offers a well-defined (programming) interface. In practice, this also means that each service offers its own interface, in turn, possibly making the composition of services far from trivial.