Thursday 02/10/2025

---
#### Transparency 

| Transparency | Description                                                           |
| ------------ | --------------------------------------------------------------------- |
| Access       | Hide differences in data representation and how an object is accessed |
| Location     | Hide where an object is physically located in the system              |
| Migration    | Hide that an object may move to another location                      |
| Relocation   | Hide that an object may be moved to another location while in use     |
| Replication  | Hide that an object is replicated                                     |
| Concurrency  | Hide that an object may be shared by several competitive users        |
| Failure      | Hide the failure and recovery of an object                            |
  
**Middleware and Openness**
**Open distributed system**: a system that offers components that can easily be
used by, or integrated into other systems. An open distributed system itself will
often consist of components that originate from elsewhere.

They share the same interface and communicate with the same common protocol. Be able to interact with services from other open systems, irrespective of the underlying environment:

Systems should conform to well-defined interfaces, easily interoperate, support portability of applications and be easily extensible.

### Scalability
• We need to consider whether a DS scales in
– Size: number of users and/or processes
– Geographically: maximum distance between nodes
– Administratively: number of administrative domains, e.g. Google data centres worldwide

DS is scalable in size if it remains effective after a significant increase in the number of users/resources
– Example: Internet
– Poor scalability if cost of supporting n users is worse than O(n)
– Scalability improves if information is organised hierarchically rather than linearly; Cost becomes O(log(n))
#### Scalability Issues
• Geographically – Synchronisation and Communication
	• client sends request to server and waits for an answer: latency easily prohibits this scheme
	• Wide Area Networks (WAN) links are often inherently unreliable
• Administratively
– Dependent/independent administrative domains
– Possible conflicting policies
	• Resource usage, management, security
#### Scaling Techniques (1)
**Hiding Communication latencies**
The difference between letting:
	a) a server or
	b) a client check forms as they are being filled
#### Scaling Techniques (2)
**Distribution & Domain Name Lookup and Addressing**
• Name table for machines on the Internet was originally a single master file, held on one server
• Centralised approach works for a network consisting of a few hundred machines 
	Does not scale well
• Domain Name System (DNS) partitions name table between servers distributed across the Internet, administered locally
• Hierarchical nature of DNS means that name lookup does not take twice as long when number of machines on the Internet doubles
#### Scaling Techniques (3)
**Replication**
• Replicate components across a DS
	Increases availability
	Helps balance the load between components
	Can hide communication latency problems
• Drawback
	Having multiple copies (cached or replicated), leads to inconsistencies: modifying one copy makes that copy different from the rest.
	Always keeping copies consistent and in a general way requires global synchronisation on each modification.
	Global synchronisation precludes large-scale solutions.
#### Developing Distributed Systems: Pitfalls
• Many distributed systems are needlessly complex caused by mistakes that required patching later
• Many false assumptions are often made:
1. The network is reliable
2. The network is secure
3. The network is homogeneous
4. Topology doesn't change
5. Latency is zero
6. Bandwidth is infinite
7. Transport cost is zero
8. There is one administrator

Question: Is there a 9th fallacy?
#### Examples
Consider computational capacity. 
Imagine a service for computing optimal routes taking real-time traffic information into account. 
- This may be primarily a compute-bound service requiring several (tens of) seconds to complete a request. 
- If there is only a single machine available, then even a modern high-end system will eventually run into problems if the number of requests increases beyond a certain point.

Likewise, we will run into problems when having a service that is mainly I/O bound. 
A typical example is a poorly designed centralized search engine. 
- The problem with content-based search queries is that we essentially need to match a query against an entire data set. 
- Even with advanced indexing techniques, we may still face the problem of having to process a huge amount of data exceeding the main-memory capacity of the machine running the service. 
- As a consequence, much of the processing time will be determined by the relatively slow disk accesses and transfer of data between disk and main memory. 
- Simply adding more or higher-speed disks will prove not to be a sustainable solution as the number of requests continues to increase.

Finally, the network between the user and the service may also be the cause of poor scalability. Just imagine a video-on-demand service that needs to stream high-quality video to multiple users. 
- A video stream can easily require a bandwidth of 8 to 10 Mbps, meaning that if a service sets up point-to-point connections with its customers, it may soon hit the limits of the network capacity of its own outgoing transmission lines.


