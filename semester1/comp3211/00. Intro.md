Monday 29/09/2025

---
Potential option for supervisor.
#### Module Objectives
Ability to:
- identify the paradigms that determine the requirements, capabilities and performance of  distributed systems
- design a high-level framework of a distributed system based on the Internet architecture / advanced architectures
- use a range of middleware tools to implement a distributed system
- reason about the significance of the new directions that distributed systems are taking.

Use proscribed textbook and Computer Networking book (K. Ross). 
This is the module to get good at for job role next year. 

For this week, read the proscribed book and revise the following
1. Sockets programming
2. Multi-threading
3. Network programming
#### Course Outline
**Part 1**
– Architectures
– Middleware
– Distributed object technology, communication
– Service Oriented Architectures and Web services (REST)
– Micro-services and nano-services
– Server-less architectures

**Part 2**
– Supporting services: naming, directory and discovery services, synchronisation, consistency, replication, fault-tolerance

**Part 3**
– Cloud computing, Virtualisation, Edge computing

Goals
• Understand what a distributed system (DS) is
• Place distributed systems in a realistic context through examples
• Motivate the benefits of resource sharing
• Gain an understanding of some challenges as they apply to distributed systems

Overview:
• Definition of a DS
• Goals and challenges
• Sharing of resources
• Transparency
• Openness
• Scalability
• Summary
#### **Definition of a Distributed System** (1)
A distributed system is:
A collection of autonomous computing elements (nodes) that appears to its users as a single coherent system [TvS2024]

Nodes: Hardware devices and software processes (e.g. computer, car, robot). These nodes need to collaborate.
An autonomous node has its own notion of time. Every node has its own clock. 
There is no global clock: this is needed for synchronisation.

An autonomous node also needs to communicate to other nodes: this provides network support.
#### **Definition of a Distributed System** (2)
A system in which components located at networked computers communicate and coordinate their actions only by passing messages [CDKB2017]

The collection of nodes as a whole operates the same –no matter where, when or how the interaction takes places between the user and that system.

E.g. An end-user cannot tell where the computation is taking place
Where data is stored exactly should be irrelevant to an application
Whether or not data has been replicated is completely unknown/hidden. (Distribution transparency)

“You know you have a DS when the crash of a computer you’ve never heard of stops you from getting any work done” – Leslie Lamport
##### **What’s the difference between a distributed and decentralised system?**

Decentralised → Distributed
![[centralised-decentralised-distributed-system.png]]
Adding 1 link between 2 nodes? Adding k>0 nodes?

**Realising distributed systems: Two views**
•**Integrative** view: connecting existing networked computer systems into a larger a system
•**Expansive** view: an existing networked computer system is extended with additional computers

A **decentralised** system is a networked computer system in which processes and resources are **necessarily** spread across multiple computers. (typically integrative view)

A **distributed** system is a networked computer system in which processes and resources are **sufficiently** spread across multiple computers. (typically expansive view)

In a decentralised system, data is normally brought to the high-performance computers that literally train models before they can be used. But when data needs to stay within the perimeter of an organisation (e.g. security reasons), training is brought to the data. The result is known as **federated learning**.

#### Examples of decentralised systems:
**Blockchain (distributed ledger)**
A distributed ledger, blockchain. In this case, we need to deal with the situation that participating parties do not trust each other enough to set up simple schemes for collaboration. 

Instead, what they do is essentially make transactions among each other fully public (and verifiable) by an extend-only ledger that keeps records of those transactions. The ledger itself is fully spread across the participants, and the participants are the ones who validate transactions (of others) before admitting them to the ledger. 

The result is a decentralised system in which processes and resources are, indeed, necessarily spread across multiple computers, in this case due to lack of trust.

**Geographically dispersed  decentralised systems**
Consider systems that are naturally geographically dispersed. This occurs typically with systems in which an actual location needs to be monitored, for example, in the case of a power plant, a building, a specific natural environment, and so on. 

The system, controlling the monitors and where decisions are made, may easily be placed somewhere else than the location being monitored. 

One obvious example is monitoring and controlling of satellites, but also more mundane situations as monitoring and controlling traffic, trains, etc. 

Here, the necessity for spreading processes and resources comes from a spatial argument.

**Content Delivery Networks (CDNs)**
An entirely different type of distributed system is formed by the collection of CDNs. 
What it boils down to, is that the content of an actual Website, is copied and spread across various servers of the CDN. 

When visiting a Website, the user is transparently redirected to a nearby server that holds all or part of the content of that Website. 

The choice for which server to direct a user to may depend on many things, but surely when dealing with streaming content, a server is selected for which good performance in terms of latency and bandwidth can be guaranteed. 

The CDN dynamically ensures that the selected server will have the required content readily available, as well as update that content when needed, or remove it from the server when there are no or very few users to service there. 

Meanwhile, the user knows nothing about what is going on behind the scenes (which, again, is a form of distribution transparency). 

We also see in this example, that content is not copied to all servers, yet only to where it makes sense, that is, sufficiently, and for reasons of performance.

CDNs also copy content to multiple servers to provide high levels of dependability.

**Network-Attached Storage (NAS)**
As a final, much smaller distributed system, consider a setup based on a NAS. For domestic use, a typical NAS consists of 2–4 slots for internal hard disks. 

The NAS operates as a file server: it is accessible through a (generally wireless) network for any authorised device, and as such can offer services like shared storage, automated backups, streaming media, and so on. 

The NAS itself can best be seen as a single computer optimised for storing files, and offering the ability to easily share those files. The latter is important, and together with multiple users, we essentially have a setup of a distributed system. 

The users will be working with a set of files that are locally (i.e., from their laptop) easily accessible (in fact, seemingly integrated into the local file system), while also directly accessible by and for other users. 

Again, where and how the shared files are stored is hidden (i.e., the distribution is transparent). Assuming that sharing files is the goal, then we see that indeed a NAS can provide sufficient spreading of processes and resources.
#### Challenges for Distributed Systems
• Architecture: common organisations, common styles
• Process: what kind of processes, and their relationships
• Communication: facilities for exchanging data
• Coordination: application-independent algorithms
• Naming: how do you identify resources?
• Consistency and replication: performance requires of data, which need to be the same
• Fault tolerance: keep running in the presence of partial failures
• Security: ensure authorised access to resources

What Do We Want to Achieve?
• Support sharing of resources: File sharing on p2p, shared web hosting, shared cloud-based storage
• **Distribution transparency**:
	The phenomenon by which a distributed system attempts to hide the fact that its processes and resources are physically distributed across multiple computers, possibly separated by large distances
	
	This is handled through many different techniques in a layer between applications and operating systems: a middleware layer: Multiple computers with varying OS will access the same interface and will eventually arrive at the same network.

Distributed and decentralised systems suffer almost continuously from
partial failures: some process or resource, somewhere at one of the
participating computers, is not operating according to expectations.
Discovering that failure may actually take some time, while also such
failures are preferably masked (i.e., they go unnoticed for users and
applications), including the recovery from failures.

• Much related to partial failures is the fact that in many networked
computer systems, participating nodes, processes, resources, and so
on, come and go. This makes these systems highly dynamic, in turn
requiring forms of automated management and maintenance, in turn
increasing the complexity.
• The fact that distributed and decentralised systems are networked, used
by many users and applications, and often cross multiple administra-
tive boundaries, make them particularly vulnerable to security attacks.
Therefore, understanding these systems and their behaviour, requires
that we understand how they can be, and are secured. Unfortunately,
understanding security is not that easy.
#### Middleware is the OS of DS
Its the glue between apps and OS, extending over multiple machines; contains commonly used components and functions that need not be implemented by applications separately

Limited transparency: network services, e.g. sockets are directly visible to app dev
Significant amount of explicit code needed to establish comms between client and server (TCP/IP, UDP/IP)

Would be nice if …
– Client and server designed and implemented as if they were components of a centralised system
– Use of sockets could be hidden from programmer
• Openness
• Scalability