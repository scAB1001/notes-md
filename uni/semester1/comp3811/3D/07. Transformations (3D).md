Thursday 20/11/2025

---
Mostly relates to the vertex processing stage, shaders too (also extra metadata relatead to input data)

 Code highlighted in yellow has changed (now using 4x4 matrix and vector of 4 too)
 What does `uModelViewProjection` represent?

### Relevant topics
- Handedness of coordinate systems
- Constructing matrices
- Hierarchical transformations
## Spaces
### Model space
Chair example in model (local) space, give it (0, 0, 0) vertex positions (v_model)

### World space
Now put it into world space: positions for each vertex. 
v_world = m_world * v_model

Instancing:
Single object (e.g., this chair) placed multiple times in the scene.
Each instance has a different transformation, but only store one copy of the objectâ€™s data.
v_world = m'_world * v_model

### Camera space
View/eye/camera space. Position relative to camera using a transformation.
v_camera = m_camera * v_modelworld

**NEGATIVE COORDINATES ARE IN FRONT OF YOU.**

You are moving the world not the camera.

### Clip space
Unit/clip space: 
We have 3D coordinates but need to fit in space. We go from 3D to 2D but keeping depth along the way to identify objects in the space (which space??)
X TO 1?

Clip space: Clipping takes place here
- Anything outside of the view is discarded
- Fixed function (hardware)
#### OPENGL WILL DO THIS FOR YOU!
Homogenization:
v_ndc = v_clip / v_clip.w

We want pixel coordinates - normalise the ... coordinates and so we perfrom perspective division and are now in 3D again

### Normalized Device Coordinates (NDC) 
E.g. convert (-1, -1, z) to screen coordinates (0, 0, z) - bottom left
#### OPENGL WILL DO THIS FOR YOU!
Viewport transform (scale from NDC to window size) glViewport
## Overview
You can choose to not have some spaces, typically no camera space.

Old OpenGL compresses these into a single MODELVIEW
transform.
(We will also prefer to combine them into a single matrix
when possible.)
- Model space: defined by us
- World space: defined by us
- Camera space: defined by us
- Perspective camera: position, forward, up; field of view; near and far
- Clip space: defined by OpenGL (homogeneous coordinates)

Most of OpenGL is right-handed coordinates system so will have to change the clip space/NDC.
- NDC: defined by OpenGL
	- Always from (-1, -1, -1) to (+1, +1, +1). *Unit cube*, Left-handed
	- Vulkan: (-1, -1, **0**) to (+1, +1, +1). Right-handed
### Left-handed vs. Right-handed
- Determines orientation of axes relative to each other
- RH: Default coordinate system in e.g. physics
- (Except when torturing students with mirrorsâ€¦)
- Most of OpenGL, all(?) of Vulkan
- DirectX: left handed :-)
- Less important in modern APIs
(adjust in vertex shader/projection)
![[right-hand-rule.png]]
### Screen space: scaled + translated version of NDC
- To â€œpixelâ€ coordinates
- (0,0) to (w,h)
- For 1920 x 1080: (0,0) to (1920, 1080) exclusive
Defined by viewport:
```cpp
glViewport x, y, width, height )
	x_window = x_ndc + 1 * width/2 + x
	y_window = y_ndc + 1 * width/2 + y
```
### Summary â€“ Vertex processing
- Define models in model space: ğ’—ğ‘šğ‘œğ‘‘ğ‘’ğ‘™ (vertex positions)
- Transform to world space: ğ’—ğ‘¤ğ‘œğ‘Ÿğ‘™ğ‘‘ = ğ‘€ğ‘¤ğ‘œğ‘Ÿğ‘™ğ‘‘ ğ’—ğ‘šğ‘œğ‘‘ğ‘’ğ‘™
- Instancing: multiple copies of the same object with different transformations
- Transform to camera space: ğ’—ğ‘ğ‘ğ‘šğ‘’ğ‘Ÿğ‘ = ğ‘€ ğ‘ğ‘ğ‘šğ‘’ğ‘Ÿğ‘ ğ’—ğ‘¤ğ‘œğ‘Ÿğ‘™ğ‘‘
- Relative to camera
- Projection gets us to clip space: ğ’—ğ‘ğ‘™ğ‘–ğ‘ = ğ‘€ ğ‘ğ‘Ÿğ‘œğ‘— ğ’—ğ‘ğ‘ğ‘šğ‘’ğ‘Ÿğ‘
- ğ’—ğ‘ğ‘™ğ‘–ğ‘ = ğ‘€ ğ‘ğ‘Ÿğ‘œğ‘— ğ‘€ ğ‘ğ‘ğ‘šğ‘’ğ‘Ÿğ‘ ğ‘€ğ‘¤ğ‘œğ‘Ÿğ‘™ğ‘‘ ğ’—ğ‘šğ‘œğ‘‘ğ‘’ğ‘™
- ğ’—ğ’„ğ’ğ’Šğ’‘ = ğ‘´ ğ’‘ğ’“ğ’ğ’‹ğ‘ªğ’‚ğ’ğ’†ğ’“ğ’‚ğ‘¾ğ’ğ’“ğ’ğ’… ğ’—ğ’ğ’ğ’…ğ’†ğ’
with ğ‘´ ğ’‘ğ’“ğ’ğ’‹ğ‘ªğ’‚ğ’ğ’†ğ’“ğ’‚ğ‘¾ğ’ğ’“ğ’ğ’… = ğ‘€ ğ‘ğ‘Ÿğ‘œğ‘— ğ‘€ ğ‘ğ‘ğ‘šğ‘’ğ‘Ÿğ‘ ğ‘€ ğ‘¤ğ‘œğ‘Ÿğ‘™ğ‘‘

**PRECOMPUTE THIS MATRIX AND USE IN UR VERTEX SHADER**

#### Key takeaway:
- Can do vertex transforms with a single 4x4 matrix mult per vertex
- Combination of various matrices
- Next up: Rotation, translation, scaling
- Then: 4x4 matrices, projection
### Vertex shader sample
```cpp
#version 430
// Input data
layout( location = 0 ) in vec3 iPosition;

// Uniforms
layout( location = 0 ) uniform mat4 uModelViewProjection;
void main()
{
	gl_Position = uModelViewProjection * vec4( iPosition, 1.0 );
}
```
`ModelViewProjection`: traditional name
I tend to prefer e.g. `ProjCameraWorld` or similar. Up to you.
### Recap: translation
- Vertex position ğ’— = (v_x, v_y, v_z) (a point)
- Translation vector ğ’• = (t_x, t_y, t_z) (a vector)
- Translation: ğ’—â€² = ğ’— + ğ’•
- Same as in 2D, except with one more coordinate
### Recap: scaling
- Vertex position ğ’— = vx, vy, vz (a point)
- Scaling matrix ğ‘† =
ğ‘ ğ‘¥ 0 0
0 ğ‘ ğ‘¦ 0
0 0 ğ‘ ğ‘§
- Scaling: ğ’—â€² = ğ‘† ğ’—
- Again, same as in 2D, except with one more coordinate
### Rotation
- Bit more complicated.
- 2D: rotation with a single angle
R2D(ğœƒ) = cos ğœƒ âˆ’ sin ğœƒ
sin ğœƒ cos ğœƒ
3D: rotation around each axis possibleâ€¦
- Three different rotation matrices:
Rz(ğœƒ) =
cos ğœƒ âˆ’ sin ğœƒ 0
sin ğœƒ cos ğœƒ 0
0 0 1 (same as 2D, but with extra coordinate)

Rx(ğœƒ) =
1 0 0
0 cos ğœƒ âˆ’ sin ğœƒ
0 sin ğœƒ cos ğœƒ

Ry(ğœƒ) =
cos ğœƒ 0 sin ğœƒ
0 1 0
âˆ’ sin ğœƒ 0 cos ğœƒ

- Compose arbitrary rotations from these three
- Warning: Gimbal lock (when you look up and left then right but you just rotate instead)
- Create rotations around an arbitrary axis rx, ry, rz (unit vector)
	- See e.g. https://learnopengl.com/Getting-started/Transformations
	- (I almost never use this)
- Can also use quaternions
### Scaling/Rotation and Translation
- Two options:
	- â€œSeparateâ€
	- Single 4x4 matrix (second half)
#### Separate
- Affine transform: ğ‘‡ ğ’— = ğ‘€ ğ’— + ğ’•
- Two affine transforms:
ğ‘‡ ğ’— = ğ‘€0 ğ’— + ğ’•0
ğ‘„ ğ’— = ğ‘€1 ğ’— + ğ’•1

- We can combine them.
	- Start with ğ’—
	- First, transform by ğ‘‡: ğ’—â€™ = ğ‘‡ ğ’—
	- Then, transform by Q: ğ’—â€™â€™ = ğ‘„ ğ’—â€² = ğ‘„(ğ‘‡(ğ’—))

- Combined:
ğ‘„ ğ‘‡ ğ’— = ğ‘€1ğ‘‡ ğ’— + ğ’•1 = ğ‘€1 (ğ‘€0 ğ’— + ğ’•0) + ğ’•1
= ğ‘€1ğ‘€0 ğ’— + ğ‘€1ğ’•0 + ğ’•1
= ğ‘€10 ğ’— + ğ’•10
(where ğ‘€10 = ğ‘€1 ğ‘€0 (matrix) and ğ’•10 = ğ‘€1ğ’•0 + ğ’•1 (vector)
##### Ordering
- In general: T(Q(v)) != Q(T(v)) !
- ğ‘„ ğ‘‡ ğ’— = ğ‘€1ğ‘€0 ğ’— + ğ‘€1ğ’•0 + ğ’•1 = ğ‘€10 ğ’— + ğ’•10
- ğ‘‡ ğ‘„ ğ’— = ğ‘€0ğ‘€1 ğ’— + ğ‘€0ğ’•1 + ğ’•0 = ğ‘€01 ğ’— + ğ’•01
ğ‘€10 â‰  ğ‘€01
ğ’•10 â‰  ğ’•01
#### 4x4 matrix
- Decent option:
	- 4x4 matrix: 16 floats
	- Separate: 3x3 matrix + 3D vector: 9+3 = 12 floats
- Also a bit cheaper to compute
- But no projections
##### As operators?
- Functions: a bit awkward to write / manipulate
ğ‘ˆ (ğ’—) = ğ‘„( ğ‘‡( ğ’—))
- Operator-like notation: Q^ = Q(.)
- So, U^ = Q^ *T^* *v (Basically: skip parentheses)
- Same rules as for matrices (associative but not commutative)

							Block equation of maths
### Hierarchical transforms
![[arm-claw-clip-art.png]]
Claw can rotate independently
Claw is relative to arm!
							Block equation of maths
