Monday 03/11/2025

---
#### Goals: 
To understand principles behindnaming in a distributed system
#### Outline
- Fundamental concepts
- Classes of naming systems
- Namespaces
- Naming graphs
- Conclusion
####  Definitions
- **Entities** in any computer system must be given **names** if we are to have access to them.
	- Entity is a resource such as a computer, printer, disk, file, web page, newsgroup, remote object . . .
	- Name is a string of bits or characters (possibly human-readable)
- Names must be **bound** to attributes of an entity; normally, one of those attributes will give us access to the entity.
- Name is **resolved** when we translate it into those attributes.
- In a distributed system, the implementation of a naming system is itself often described across **multiple machines**.
##### Name Resolution Example
![[name-res-ex.png]]
#### Access Points and Addresses
- To operate on an entity, we need another special kind of entity called an **access point**.
- Name of the access point is called the **address**, usually thought of as address of entity itself.
	- An entity can have more than one access point.
	- An entity’s access points may change over time.
- In general we don’t want to use an address as the regular name for an entity; better to adopt a **location-independent** name.
#### Function of a Naming System
- A **naming system (service)** manages set of bindings between names and attributes of entities in the system.
- Primary function is **name resolution**
	- Looking up entity attributes from a given name.
- Secondary functions are
	- Creation of new bindings
	- Deletion of existing bindings
	- Listing of bound names
	- Organisation of the namespace
#### Classes of Naming Systems
1. Flat naming
	a. Broadcasting
	b. Forwarding pointers
	c. Home-based approaches
	d. Distributed Hash Tables
	e. Hierarchical approaches
2. Structured naming (next lecture)
3. Attribute-based naming (next lecture)
##### Flat Naming Systems
- Entities are referred to by an **identifier** that in principle has no meaning at all
- Flat names bare no structure
	- Need special mechanisms to trace the location of entities
- Questions
	- How flat names can be resolved?
	- How can we locate an entity when given only its identifier
##### a) Broadcasting
**Broadcast the ID**, requesting the entity to return its current address
- Can never scale beyond local-area networks
	- Requires all processes to listen to incoming location requests
- *Example: Address Resolution Protocol (ARP)*
	- To find out which MAC address is associated with an IP address, broadcast the query: 
	”Who has this IP address”?
#### b) Forwarding Pointers
When an entity moves from A, **it leaves behind a pointer** to its next location B
- Dereferencing can be made entirely transparent to clients by simply following the chain of pointers
	- Update a client's reference when present location is found
	- Geographical **scalability problems** (for which separate chain reduction mechanisms are needed):
- Long chains are not fault tolerant
- Increased network latency at dereferencing
##### Example: SSP Chains
- The principle of forwarding pointers using (client stub, server stub)
- SSP: Stub-Scion Pair
- Typical in object invocation
![[naming-pt1-ssp-chains-ex.png]]
Redirecting a forwarding pointer by storing a **shortcut** in a client stub:
![[ssp-chains-a-and-b.png]]
#### c) Home-based Approach
Single-tiered scheme: Let a **home** keep track of where the entity is
- Each mobile host uses a **fixed IP address**
- Communication to that IP address is initially directed to the mobile host’s home agent
- The **home agent** is located on the local-area network corresponding to the network address contained in the mobile host’s IP address
	- Realised as a network layer component in IPv6
- Whenever the mobile host moves to another network, it requests a **(temporary) foreign address** that it can use for communication
	- This **care-of-address** is registered at the home agent.
##### Example: Mobile IP
When the home agent receives a packet for the mobile host, it looks up the host’s current location
- If the host is on the current local network, the packet is **simply forwarded**
- If it is not, it is **tunnelled** to the host’s current location, i.e. wrapped as data in an IP packet and sent to the **care-of- address**
- The sender of the packet is informed of the host’s current location
- Note: whole mechanism largely hidden for applications
	- High degree of **location transparency**.
![[mobile-ip-world-map-ex.png]]
1. CLient has host number
2. Go to host current location-> return that addr to client, tunnel packet to client
3. Client tunnels ... ==TODO:==
##### Problems with Home-based Approaches
Problems identified:
- Home address support for entity?
- Home address is fixed. So? 
- Increase in communication latency?
- Poor geographical scalability?
	- If client and host are in same place, the same process has to happen so wasteful.
#### d) Distributed Hash Tables
Consider the organisation of many nodes into a **logical ring**
- Each node is assigned a random m-bit **identifier**.
- Every entity is assigned a unique m-bit **key**.
- Entity with key `k` falls under jurisdiction of node with **smallest** id `k` (called its **successor** `succ(k)`).
*Note*: Non-solution is to let each node keep track of its neighbour and start linear search along the ring.
Notation: We will speak of node `p` as the node having identifier `p`
##### Principle
![[distributed-hash-table-principle.png]]

