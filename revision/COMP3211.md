# Structure
### Course Outline
#### Part 1
- Architectures
- Middleware
- Distributed object technology, communication
- Service Oriented Architectures and Web services (REST)
- Microservices and nanoservices
- Serverless architectures
#### Part 2
- Supporting services: naming, directory and discovery services, synchronisation, consistency, replication, fault- tolerance
#### Part 3
- Cloud computing, Virtualisation, Edge computing
## Part 1
### 1. Introduction to Distributed Systems Pt.1 - *Chapter 1*
- Definition of a DS
- Goals and challenges
- Sharing of resources
- Transparency
- Openness
- Scalability
### 2. Introduction to Distributed Systems Pt.2 - *Chapter 1* 
- Types of distributed systems
1. High performance distributed computing systems
2. Distributed information systems
3. Distributed systems for pervasive computing
- *Homework*: What is Google spanner? 
	- What consistency properties does it have?
	- How does it handle ACID transactions?
### 3.  Architectures - *Chapter 2*
- Understand the different ways on how to view the organisation of a distributed system
- Architectural styles
	- Layered
	- Object-based
	- Resource-centred
	- Event-based
- System architecture
	- Centralised
	- Decentralised
	- Hybrid
### 4. Communication - *Chapter 4*
- Foundations
	- Latency and Bandwidth
	- Layered Protocols
	- Types of communication
		- Synchronous vs asynchronous
		- Transience vs persistence
- Remote Procedure Call
- Message Oriented Middleware
	- Message oriented communication
	- Message Passing Interface
	- Message Queuing Model
### 5. Service Oriented Architectures
- Conceptual Design of Software Systems
- Architectures
	- 1-Tier
	- 2-Tier
	- 3-Tier
	- N-Tier
- Emergence of SOAs
- Vision
- Characteristics
### 6. Web Services and REST
- Why do we need Web services?
- What are web services?
- What is REST?
- What does it consist of?
- Claimed benefits
- HTTP
### 7. Programming RESTful Web Services
- REST: Quick Recap
- REST APIs: Examples
- Reference implementations:
	- Python (Flask Restful)
	- Java (Jersey)
- Data encoding and RPC
### 8. Microservices, Nanoservices and Serverless
- Recap: SOAs
- Microservices
- Nanoservices
- Serverless Computing
- Function as a Service
- Architectural Support
- Solutions
## Part 2
### 9. Naming Pt.1 - *Chapter 5*
- Fundamental concepts
- Classes of naming systems
- Namespaces
- Naming graphs
### 10. Naming Pt.2 - *Chapter 5*
- Structured naming
	- Namespaces
	- Name resolution
	- Implementation of a namespace
- Attribute-based naming
- Directory Services
### 11. Timing and Synchronisation - *Chapter 6*
- Synchronisation in a DS
- Internal and external physical clocks
- Clock synchronisation algorithms
- Election Algorithm
- Network time protocol (NTP)
### 12. Consistency and Replication Pt.1 - *Chapter 7*
- Data-centric consistency models
### 13. Consistency and Replication Pt.1 - *Chapter 7*
- Client-centric consistency models
- Replica management
- Consistency protocols
### 14. Fault Tolerance - *Chapter 8*
- Dependability, reliability and availability in a DS
- Terminology
- Failure models
- Process resilience
- Consensus with crash failures
- Consensus with arbitrary failures
- The Byzantine Generals Problem
- *Homework*: The Paxos consensus algorithm is a protocol used in distributed systems to allow a group of computers to agree on a single value despite failures. How does Paxos compare to Raft?
## Part 3
### 15. Cloud Computing
- Technology Landscape
- Towards a Definition of Cloud Computing
- Virtualised infrastructures
- Conceptual Cloud Architecture
- Taxonomy of cloud Models
- Virtual Infrastructure Managers
- Cloud services
- Types of Clouds
### 16. Distributed Systems Topics and Trends Pt.1
- IoT: the Internet of Things
- Edge Computing
- Revisiting the Cloud Computing Stack
- Vision for a (near) future
### 17. Distributed Systems Topics and Trends Pt.2
- Module themes
- Evolution of distributed computing
- Most Active Topics in Distributed Systems-
# Content 
## 1. Introduction to Distributed Systems Pt.1 - *Chapter 1*
### Definition of a DS
> (1) A collection of *autonomous computing elements* (nodes) that appears to its *users* as a *single coherent system*.

NODES: Hardware devices and software processes (e.g. computer, car, robot) that need to collaborate. An AUTONOMOUS node has its own *notion of time* as every node has its own clock. 
There is no GLOBAL clock which is needed for synchronisation.
An autonomous node also needs to communicate to other nodes, providing network support.

> (2) A system in which components located at *networked* computers *communicate* and coordinate their actions only by *passing messages*.

The collection of nodes as a whole operates the same –no matter *where, when or how* the interaction takes places between the user and that system.
For example: 
- An end-user cannot tell where the computation is taking place
- Where data is stored exactly should be irrelevant to an application
- Whether or not data has been replicated is completely unknown/hidden. (Distribution transparency)

#### 
“You know you have a DS when the crash of a computer you’ve never heard of stops you from getting any work done” – Leslie Lamport
### Goals and challenges
### Sharing of resources
### Transparency
### Openness
### Scalability