Repeat. 
Goals: understand principles behind consistency and replication Outline:
Outline:
## 13. Consistency and Replication Pt.1 - Chapter 7
### Client-centric consistency models
#### Basic Architecture
#### Monotonic Reads
#### Monotonic Writes
#### Read Your Writes
### Replica management
#### Content Replication
#### Server-Initiated Replica Example
#### Consistency Protocols: Primary-backup Protocol Example
#### Consistency Protocols: Primary-backup Protocol with Local Writes
Content:
### Client-centric consistency models
Consider a distrbuted db where only accessed by a notebook which is the front end to your db.
At location A you access the db doing reads and updates.
At location B you continue your work but unless you access the same server as location A, you may detect inconsistencies:
- updates at A may not have been propagated to B
- you may be reading new entries than the ones available at A
- updates may eventually conflict with A's
All you want is a db that appears consistent to you, where entries updated/read at A, are in B the way you left them in A.

Data-centric consistency models aim at providing a systemwide consistent
view on a data store. An important assumption is that concurrent processes
may be simultaneously updating the data store, and that it is necessary to
provide consistency in the face of such concurrency. For example, in the case
of object-based entry consistency, the data store guarantees that when an
object is called, the calling process is provided with a copy of the object that
reflects all changes to the object that have been made so far, possibly by other
processes. During the call, it is also guaranteed that no other process can
interfere, that is, mutual exclusive access is provided to the calling process.
Being able to handle concurrent operations on shared data while maintain-
ing strong consistency is fundamental to distributed systems. For performance
reasons, strong consistency may possibly be guaranteed only when processes
use mechanisms such as transactions or synchronization variables. Along the
same lines, it may be impossible to guarantee strong consistency, and weaker
forms need to be accepted, such as causal consistency in combination with
eventual consistency.
In this section, we take a look at a special class of distributed data stores.
The data stores we consider are characterized by the lack of simultaneous
updates, or when such updates happen, it is assumed that they can be
relatively easily resolved. Most operations involve reading data. These data
stores offer a weak consistency model, such as eventual consistency. By
introducing special client-centric consistency models, it turns out that many
inconsistencies can be hidden in a relatively cheap way
#### Basic Architecture
![[client-centric-arch.png]]
Provides guarantees for a single client concerning the consistency
of accesses to a data store by that client
• No guarantees are given concerning concurrent accesses by
different clients.
• If P1 modifies data that is shared with P2 but which is stored at a
different location, write-write conflicts may easily be created.

$x_i$ denotes the version of data item $x$, $L_k$ denotes the local store $k$.
$$\begin{align}
W_1(x_2) \text{ is the write op by } P_1 \text{, leads to version } x_2 \text{ of } x \\
W_1(x_i;x_j) \text{ indicates } P_1 \text{ produces version } x_j \text{ based on previous } x_i \\
W_1(x_i;x_j) \text{ indicates } P_1 \text{ produces version } x_j \text{ concurrently to } x_i
\end{align}$$
#### Monotonic Reads (MRs)
If a process reads the value of data item x, any successive read op on x by that process will always return that same or most recent value.

In other words, monotonic-read consistency guarantees that once a process
has seen a value of x, it will never see an older version of x.

The read ops performed by a single process P at two different local copies of the same data store. a) A monotonic read consistent data store b) A data store that does not provide monotonic reads.
(**Example1**) a distributed e-mail database
![[monotonic-read-ex-1.png]]
• W2(x1|x2) at L2 is known to produce a version that does not follow from x1
• Consequence, P1’s read operation at L2 is known not to include the effect of the
write operations when it performed R1(x1) at location L1.

(**Example2**) Automatically reading you personal calnedar updates from diff servers.
MRs guarantees that the user sees all updates, no matter which automatic read takes place. 

(**Example3**) Reading (no modification) incoming mail while you are mobile. Each time you connect to a diff e-mail server, that server fetches (at least) al the updates from the server you previously visited.
#### Monotonic Writes (MWs)
In many situations, it is important that write operations are propagated in
the correct order to all copies of the data store. This property is expressed
in monotonic-write consistency. In a monotonic-write consistent store, the
following condition holds:
A write op by a process on a data item x is completed before any successive write op on x by the same process.

**(EXAMPLE 1)**
![[monotonic-write-ex1.png]]
a) A MW consistent data store. b) A data store that is not MW consistent.
c) Non MW consistent as WS(x1|x2) and WS(x1|x3).
d) MW consistent as WS(x1;x3) although x1 has overwritten x2.

**(EXAMPLE 2)** Updating a program at server S2 and ensuring all compilation and link dependant components are also on S2.

**(EXAMPLE 3)** Maintaing versions of replicated files in the correct order everywhere (propagate the prev version to the server where the newest version is)
#### Read Your Writes (RYWs)
The effect of a write op by a process on data item x will always be seen by a successive read op on x by the same process.
In other words, a write operation is always completed before a successive read
operation by the same process, no matter where that read operation takes
place.
**(EXAMPLE 1)**
a) A data sttore that provides RYW consistency. b) A data store that doesn't.
![[read-your-write-consistency-1.png]]
(b) Effects of previous write operation by P1 have not been propagated to L2 at the
time x2 was produced
• P1 reads x2: will not see the effects of its own write operation at L1
**(EXAMPLE 2)** Updating your web page and guaranteeing that your web browser shows the newest version instead of its cached copy. READING the actual new one.
### Replica management
#### Content Replication
#### Server-Initiated Replica Example
#### Consistency Protocols: Primary-backup Protocol Example
#### Consistency Protocols: Primary-backup Protocol with Local Writes