Goals: understand principles behind timing and synchronisation in a distributed system
Outline:
## 11. Timing and Synchronisation - *Chapter 6*
### Synchronisation in a DS
### Internal and external physical clocks
### Clock synchronisation algorithms
### Election Algorithm
### Network time protocol (NTP)
A Detective Story:
In the night from 30 June to 1 July 2012 (UK time), many
online services and systems around the world crashed
simultaneously.
Servers locked up and stopped responding.
Some airlines could not process any reservations or check-
ins for several hours.
What happened?
The Eight Fallacies of Distributed Computing by Peter Deutsch
• Essentially everyone, when they first build a distributed
application, makes the following eight assumptions. All prove
to be false in the long run and all cause big trouble and painful
learning experiences.
1. The network is reliable
2. Latency is zero
3. Bandwidth is infinite
4. The network is secure
5. Topology doesn't change
6. There is one administrator
7. Transport cost is zero
8. The network is homogeneous
9. All clocks are synchronised
#### Clocks and Time in Distributed Systems
Distributed systems often need to measure time, e.g.:
• Schedulers, timeouts, failure detectors, retry timers
• Performance measurements, statistics
• Log files & databases: record when an event occurred
• Data with time-limited validity (e.g. cache entries)
• Determining order of events across several nodes
We distinguish two types of clock:
• physical clocks: count number of seconds elapsed
• logical clocks: count events, e.g. messages sent
Source: theconversation.com
Time in a DS
• Time unambiguous (but may be inaccurate) in a
centralised system.
• In a DS, there is **no global agreement** on time.
• Question: is there any way of synchronising all the
clocks in a DS?
Note: Clock in digital electronics (oscillator) ≠ clock
in distributed systems (source of timestamps)
![[timing-clock-ex.png]]
When each machine has its own clock, an event
that occurred after another event may nevertheless
be assigned an earlier time.
#### Quartz Clocks
• Quartz crystal laser-
trimmed to mechanically
resonate at a specific
frequency
• Piezoelectric effect:
mechanical force 
electric field
• Oscillator circuit produces
signal at resonant
frequency
• Count number of cycles
to measure elapsed time
##### Quartz Clock Drift
• One clock runs slightly fast, another slightly slow
• Drift measured in parts per million (ppm)
• 1 ppm = 1 microsecond/second = 86 ms/day = 32 s/year
• Most computer clocks correct within 50 ppm
- It was found that Temperature significantly affects drift
Internal Physical Clock
• Most computers have built-in timing hardware, based
around a precisely-machined quartz crystal.
• Each oscillation of the crystal decrements a counter by 1.
• When counter reaches zero, a timer interrupt or clock
tick is generated and counter is reloaded from a
holding register.
• Battery-powered CMOS RAM stores the number of clock
ticks since a known date, allowing system to maintain a
notion of date and time.
• In a DS with n machines, all n crystals will run at
slightly different rates, resulting in clock skew.
#### Time Standards
• Before 1958, our notion of time was based on the mean
solar second: 1/(24 x 60 x 60) = 1/86,400th of a solar
day
• Since invention of atomic clock, 1 second is defined as
the time for a caesium 133 atom to make 9,192,631,770
electronic transitions.
• International Atomic Time (TAI):
1 day is 24 x 60 x 60 x 9,192,631,770 periods of
caesium-133's resonant frequency
• Mean solar day is growing longer, so if we used TAI to
keep time, noon would gradually occur earlier and earlier
. . .
• . . . hence, leap seconds were introduced whenever
discrepancy between TAI and solar time reaches 800 ms.
The Worldwide Standard For Time: UTC
![[utc-time-standard.png]]
Time system based on TAI,
corrected with leap seconds, is
called Universal Coordinated
Time (UTC).
• UTC sychronisation signals are
broadcast from shortwave radio
transmitters and satellites
• In datacenters, need antenna on
the roof.
How Computers Represent Timestamps
• Unix time: number of seconds since 1 January
1970 00:00:00 UTC (the “epoch"), not counting
leap seconds
• ISO 8601: year, month, day, hour, minute,
second, and timezone offset relative to UTC
example: 2023-11-20T09:50:17+00:00
• How most software deals with leap seconds? By
ignoring them!
OS and DS often need timings with sub-second accuracy.
30 June 2012: **bug** in Linux kernel caused livelock on leap second,
causing many Internet services to go down
Pragmatic solution: “smear" (spread out) the leap second over the
course of a day
### Clock Synchronisation Algorithms
• One machine with a UTC receiver:
– Goal is to synchronise other machines with it
– Example: **Cristian’s algorithm**
• No machines have UTC receivers:
– Goal is simply to minimise clock skew
– Example: **Berkeley algorithm**
#### Synchronisation Model
• Each machine has an internal timer, issuing H
interrupts per second.
• Interrupt handler adds 1 to software clock keeping
track of number of ticks since some standard time
in the past; value of clock is C.
• At UTC time t, value of i'th clock in system is Ci(t).
• Ideally, $Ci(t) = t + \gamma$ for all i and t, and dC/dt is 1
• In practice, H varies slightly, resulting in drift. A
timer is regarded as working properly if
$1−\rho ≤ dC/dt ≤ 1 + \rho$ where $\rho$ is **maximum drift rate**.
#### Drift as a Function of UTC
• If two clocks are drifting from UTC in opposite
directions, at a time dt after synchronisation they
may be as much as 2$\rho$dt apart.
![[drift-as-func-utc.png]]
25 February 1991. Patriot Missile Failure Example:
• Software error in the system clock. Accumulated clock drift
#### Cristian’s Algorithm
• Machine with UTC receiver is the time server.
• At intervals not exceeding dC/2$\rho$ sec, each machine
sends a message to time server, requesting current
time.
• Time server responds as fast as it can with time C_UTC
• A fast client must correct its time to C_UTC gradually, to
avoid the problem of time running backward.
• Need to deal with fact that time server’s reply is not instantaneous, with delay variable depending on network traffic
![[christian-algo.png]]
#### Estimating Time over a Network
![[est-time-over-network.png]]
**Round-trip network delay** $\delta = (t_4 - t_1) - (t_3 - t_2)$
**Estimated server time** when client receives response: $t_3 + \delta/2$
**Estimated clock skew**: $\delta = t_3 + \delta/2 – t_4 = (t_2 - t_1 + t_3 - t_4)/2$
#### Berkeley Algorithm
The time daemon asks all the other machines for their clock values
• The machines answer, daemon calculates average
• The time daemon tells everyone how to adjust their clock
![[berkley-algo-time.png]]
1. Time daemon clock $D$ shows **3:00**, requests network clock values.
2. Network clocks $C_n$, return their values to the daemon $C_1 =$ 2:50, $C_2 =$ 3:25.
3. Daemon calculates average: $$ \begin{align}
( \ \text{diff}(D, C_1) + \text{diff}(D, C_2)\ ) / \text{no. clocks} \\
( \ \text{diff}(\text{3:00}, \text{ 3:50}) + \text{diff}(\text{3:00}, \text{ 3:25})\ ) / 3 \\
( 0 -10 + 25 ) / 3 = +5 \text{ minutes}\\
\end{align}$$ 4. Daemon adjusts all clocks to match its own (3:00) + 5 more minutes= 3:05.
### Election Algorithms
• Many distributed algorithms need one process to act as **coordinator**
– Doesn’t matter which process does the job, just need to pick one
• Election algorithms: technique to pick a unique
coordinator (this is a **leader election**)
• Examples: take over the role of a failed process, pick a master in Berkeley clock synchronisation algorithm
• Example of an election algorithm: Bully algorithm Bully Algorithm
• Each process has a unique numerical ID
• Processes know the Ids and address of every other process
• Communication is assumed reliable 
(Key Idea): select process with highest ID
• Process initiates election if it just recovered from failure or if coordinator failed
• 3 message types: *election, OK, I won*
• Several processes can initiate an election simultaneously
– Need consistent result
• $O(n^2)$ messages required with $n$ processes
#### Bully Algorithm
• Any process P can initiate an election
• P sends **Election** messages to all process with higher Ids and awaits **OK** messages
• If no **OK** messages, P becomes coordinator and sends **I won** messages to all process with lower Ids
• If it receives an **OK**, it drops out and waits for an **I** **won**
• If a process receives an **Election** msg, it returns an OK and starts an election
• If a process receives a **I won**, it treats sender as coordinator
Bully Algorithm Example